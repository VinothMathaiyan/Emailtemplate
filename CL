import json
import pandas as pd
import re

def load_qsf_file(qsf_file):
    with open(qsf_file, 'r', encoding='utf-8-sig') as file:
        data = json.load(file)
    return data

def clean_html(raw_html):
    clean_text = re.sub(r'<[^>]+>', '', raw_html)  # Remove HTML tags
    clean_text = re.sub(r'&nbsp;', ' ', clean_text)  # Replace &nbsp; with space
    clean_text = re.sub(r'\s+', ' ', clean_text).strip()  # Remove extra whitespace
    return clean_text

def extract_questions(data):
    questions = []
    for element in data['SurveyElements']:
        if element['Element'] == 'SQ':
            question = element['Payload']
            question_id = question.get('QuestionID', '')
            question_text = clean_html(question.get('QuestionText', ''))
            questions.append({
                'QuestionID': question_id,
                'QuestionText': question_text,
                'QuestionType': question.get('QuestionType', ''),
                'Selector': question.get('Selector', ''),
                'SubSelector': question.get('SubSelector', ''),
                'DataExportTag': question.get('DataExportTag', ''),
                'QuestionDescription': clean_html(question.get('QuestionDescription', ''))
            })
    
    print("Extracted Questions:", questions)  # Debugging line
    return questions

def extract_question_ids_from_bl(qsf_data):
    """
    Extracts QuestionIDs and Block Names from Block Questions (BL) in the QSF data.

    Args:
        qsf_data: A dictionary containing the JSON data from the QSF file.

    Returns:
        A list of tuples containing Block Names and QuestionIDs extracted from Block Questions.
    """
    question_ids = []
    for element in qsf_data.get("SurveyElements", []):
        if element.get("Element") == "BL":
            payload = element.get("Payload", {})
            for block_id, block_data in payload.items():
                if isinstance(block_data, dict) and "BlockElements" in block_data:
                    block_name = block_data.get("Description", "Unnamed Block")
                    for block_element in block_data["BlockElements"]:
                        if "QuestionID" in block_element:
                            question_ids.append((block_name, block_element["QuestionID"]))
    
    print("Extracted Question IDs and Block Names:", question_ids)  # Debugging line
    return question_ids

def reorder_questions(questions, question_order):
    question_dict = {q['QuestionID']: q for q in questions}
    ordered_questions = [question_dict[qid] for _, qid in question_order if qid in question_dict]
    
    print("Ordered Questions:", ordered_questions)  # Debugging line
    return ordered_questions

def save_to_excel(questions, question_order, output_file):
    df_questions = pd.DataFrame(questions)
    df_order = pd.DataFrame(question_order, columns=['BlockName', 'QuestionID'])
    df_merged = pd.merge(df_order, df_questions, on='QuestionID', how='left')
    df_merged.to_excel(output_file, index=False)

if __name__ == "__main__":
    directory = 'd:/Hackaton/EXCELtoQSF'
    
    name = input("Please enter the file name without extension: ")
    qsf_file = f'{directory}/QSF/{name}.qsf'
    output_file = f'{directory}/{name}_reordered_output.xlsx'
    
    data = load_qsf_file(qsf_file)
    questions = extract_questions(data)
    question_order = extract_question_ids_from_bl(data)
    ordered_questions = reorder_questions(questions, question_order)
    save_to_excel(ordered_questions, question_order, output_file)
    print(f"Reordered questions have been successfully exported to {output_file}")
